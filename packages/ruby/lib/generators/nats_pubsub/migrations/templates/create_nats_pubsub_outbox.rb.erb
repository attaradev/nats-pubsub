# frozen_string_literal: true

class CreateNatsPubsubOutbox < ActiveRecord::Migration[<%= ActiveRecord::Migration.current_version %>]
  # Disable DDL transaction for concurrent index creation
  disable_ddl_transaction!

  def up
    # Idempotency check - safe to run multiple times
    return if table_exists?(:nats_pubsub_outbox)

    create_table :nats_pubsub_outbox do |t|
      t.string  :event_id, null: false
      t.string  :subject,  null: false
      t.jsonb   :payload,  null: false, default: {}
      t.jsonb   :headers,  null: false, default: {}
      t.string  :status,   null: false, default: 'pending'  # pending|publishing|sent|failed
      t.integer :attempts, null: false, default: 0
      t.text    :last_error
      t.datetime :enqueued_at
      t.datetime :sent_at
      t.timestamps
    end

    # Add indexes concurrently to avoid table locks
    add_index :nats_pubsub_outbox, :event_id,
              unique: true,
              algorithm: :concurrently,
              if_not_exists: true

    add_index :nats_pubsub_outbox, :status,
              algorithm: :concurrently,
              if_not_exists: true

    # Composite index for common queries (status + created_at)
    add_index :nats_pubsub_outbox, [:status, :created_at],
              algorithm: :concurrently,
              if_not_exists: true,
              name: 'index_outbox_on_status_and_created'

    # Composite index for status + enqueued_at queries
    add_index :nats_pubsub_outbox, [:status, :enqueued_at],
              algorithm: :concurrently,
              if_not_exists: true,
              name: 'index_outbox_on_status_and_enqueued'

    # Partial index for sent events (for cleanup queries)
    add_index :nats_pubsub_outbox, :sent_at,
              where: "status = 'sent'",
              algorithm: :concurrently,
              if_not_exists: true,
              name: 'index_outbox_sent_at'

    # Partial index for stale publishing records
    add_index :nats_pubsub_outbox, :updated_at,
              where: "status = 'publishing'",
              algorithm: :concurrently,
              if_not_exists: true,
              name: 'index_outbox_stale_publishing'

    # GIN index for JSONB payload queries (PostgreSQL only)
    if ActiveRecord::Base.connection.adapter_name.downcase.include?('postgres')
      add_index :nats_pubsub_outbox, :payload,
                using: :gin,
                algorithm: :concurrently,
                if_not_exists: true,
                name: 'index_outbox_payload_gin'
    end

    # Database-level constraint for status values
    execute <<-SQL
      ALTER TABLE nats_pubsub_outbox
      ADD CONSTRAINT check_outbox_status_values
      CHECK (status IN ('pending', 'publishing', 'sent', 'failed'))
    SQL
  end

  def down
    # Safe rollback with checks
    drop_table :nats_pubsub_outbox if table_exists?(:nats_pubsub_outbox)
  end
end
